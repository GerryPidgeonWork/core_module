# ====================================================================================================
# G04a_app_controller.py
# ----------------------------------------------------------------------------------------------------
# Application Controller (Control Plane)
#
# Purpose:
#   - Orchestrate application lifecycle, navigation, state, events, async tasks.
#   - Act as the central control-plane between G00â€“G03.
#   - Delegate all UI rendering to G03 renderer.
#   - Provide global actions (toast, publish, navigate, etc.)
#
# Relationships:
#   - G01: Theme initialisation only.
#   - G02: BaseWindow is injected, never created.
#   - G03: Renderer is injected, owns all UI creation.
#   - G04: Navigation, State, EventBus, Tasks, Controllers.
#
# Design principles:
#   - G04 owns behaviour only; G03 owns all UI structure.
#   - No direct widget creation.
#   - No business logic or styling.
#   - No circular dependencies.
#
# ----------------------------------------------------------------------------------------------------
# Author:       Gerry Pidgeon
# Created:      2025-12-03
# Project:      GUI Framework v1.0
# ====================================================================================================


# ====================================================================================================
# 1. SYSTEM IMPORTS
# ----------------------------------------------------------------------------------------------------
# These imports (sys, pathlib.Path) are required to correctly initialise the project environment,
# ensure the core library can be imported safely (including C00_set_packages.py),
# and prevent project-local paths from overriding installed site-packages.
# ----------------------------------------------------------------------------------------------------

# --- Future behaviour & type system enhancements -----------------------------------------------------
from __future__ import annotations           # Future-proof type hinting (PEP 563 / PEP 649)

# --- Required for dynamic path handling and safe importing of core modules ---------------------------
import sys                                   # Python interpreter access (path, environment, runtime)
from pathlib import Path                     # Modern, object-oriented filesystem path handling

# --- Ensure project root DOES NOT override site-packages --------------------------------------------
project_root = str(Path(__file__).resolve().parent.parent)
if project_root not in sys.path:
    sys.path.append(project_root)

# --- Remove '' (current working directory) which can shadow installed packages -----------------------
if "" in sys.path:
    sys.path.remove("")

# --- Prevent creation of __pycache__ folders ---------------------------------------------------------
sys.dont_write_bytecode = True


# ====================================================================================================
# 2. PROJECT IMPORTS
# ----------------------------------------------------------------------------------------------------
# Bring in shared external packages from the central import hub.
#
# CRITICAL ARCHITECTURE RULE:
#   ALL external + stdlib packages MUST be imported exclusively via:
#       from core.C00_set_packages import *
#   No other script may import external libraries directly.
#
# C01_set_file_paths is a pure core module and must not import GUI packages.
# ----------------------------------------------------------------------------------------------------
from core.C00_set_packages import *

# --- Initialise module-level logger -----------------------------------------------------------------
from core.C03_logging_handler import get_logger, log_exception, init_logging
logger = get_logger(__name__)

# --- Additional project-level imports (append below this line only) ----------------------------------
from gui.G00a_gui_packages import init_gui_theme
from gui.G02c_gui_base import BaseWindow, get_overlay_layer
from gui.G03e_widget_components import toast_notification
from gui.G03f_renderer import G03Renderer   

# --- G04 Dependencies ---
from G04b_navigation import Navigator
from G04c_app_state import AppState
from G04d_event_bus import EventBus
from G04e_async_tasks import TaskManager
from G04e_controllers import BasePageController 

if TYPE_CHECKING:
    from G04e_controllers import BasePageController 

# =====================================================================

class AppController:
    """
    Top-level orchestrator for the entire application (G04 Control Plane).

    Manages service lifecycle, navigation, state access, and robust error boundaries 
    by orchestrating G00-G03 components.
    """
    def __init__(self, routes: Dict[str, Type], ErrorPage: Type, initial_route: str, 
                 WindowInstance: BaseWindow, G03RendererInstance: G03Renderer, 
                 ControllerBase: Type = BasePageController):
        """
        Initializes the AppController with injected G03 components.
        """
        if not routes:
            raise ValueError("AppController must be initialized with at least one route.")
        if initial_route not in routes:
            raise ValueError(f"Initial route '{initial_route}' not found in routes.")
            
        # Renamed attributes for compliance
        self.routes_map = routes
        self.error_page_class = ErrorPage
        self.initial_route_id = initial_route
        self.controller_base_class = ControllerBase
        
        # Injected References
        self.window: BaseWindow = WindowInstance
        self.root: tk.Tk = self.window.root 
        self.renderer: G03Renderer = G03RendererInstance
        self.renderer.set_window(self.window)

        # Core Services (G04 components)
        self.state: AppState = AppState()
        self.events: EventBus = EventBus(self.ui_safe_callback) # Uses renamed method
        self.tasks: TaskManager = TaskManager()
        self.navigation: Navigator = Navigator(self) 

        logger.info("AppController initialized. UI components injected.")

    def run(self) -> None:
        """
        Initializes the application environment and starts the Tkinter mainloop.
        """
        if self.root is None:
             raise RuntimeError("AppController must have a valid Tk root from the injected BaseWindow.")

        self.root.withdraw() 
        
        # 1. Apply Theme (G01 Hook)
        init_gui_theme(self.root)
        
        # 2. Finalize Service Initialization
        self.tasks.set_root(self.root)
        self.navigation.register_routes(self.routes_map)
        self.navigation.set_error_page(self.error_page_class)
        
        # 3. Error Boundary Hook
        sys.excepthook = self.global_error_handler # Uses renamed method
        
        # 4. Start Application
        self.navigate(self.initial_route_id)
        self.root.deiconify() 
        try:
            self.root.mainloop()
        finally:
            sys.excepthook = sys.__excepthook__ # Restore hook


    # =================================================================
    # --- GLOBAL ACTIONS / PUBLIC API ---
    # =================================================================

    def navigate(self, route_id: str, params: Dict[str, Any] | None = None) -> None:
        """
        Triggers navigation via the Navigation Engine (G04b).
        """
        try:
            self.navigation.to(route_id, params=params)
        except Exception as e:
            self.handle_navigation_error(e)

    def get_state(self, key: str) -> Any:
        return self.state.get(key)

    def set_state(self, key: str, value: Any) -> None:
        self.state.set(key, value)

    def publish(self, event: str, payload: Dict[str, Any] | None = None) -> None:
        self.events.publish(event, payload)
        
    def show_toast(
        self,
        message: str,
        role: str = "SUCCESS",
        duration_ms: int = 3000,
    ) -> None:
        """
        Global behaviour-layer toast helper (G04 Action).

        G04 owns:
            - WHEN the toast appears
            - WHERE it appears
            - Its timing + lifecycle

        G03 owns:
            - Producing the toast widget (toast_notification)
        """
        if not self.window:
            logger.warning(f"[G04] Toast ignored (no window): {message}")
            return

        # BaseWindow MUST expose a utility to get the overlay layer.
        # If your BaseWindow does not already have this, I can generate it for you.
        parent = getattr(self.window, "get_overlay_layer", None)

        if callable(parent):
            parent_widget = self.window.get_overlay_layer()
        else:
            # Fallback: use root directly (safe for now)
            parent_widget = self.window.root

        # Create toast widget using G03 factory
        toast = toast_notification(
            parent_widget,
            message=message,
            duration_ms=duration_ms,
            role=role,
        )

        # Position overlay (non-invasive, top-centre)
        toast.place(relx=0.5, rely=0, anchor="n", y=20)
        toast.lift()

        logger.info(f"[G04] Toast shown: {message}")


    # =================================================================
    # --- ERROR BOUNDARIES ---
    # =================================================================

    def create_full_service_controller(self) -> 'BasePageController':
        """
        Creates a new controller instance with full service injection (Rule 5 compliance).
        """
        return self.controller_base_class(
            app_controller=self,
            navigator=self.navigation,
            state=self.state,
            event_bus=self.events,
            task_manager=self.tasks,
        )

    def handle_navigation_error(self, error: Exception) -> None:
        """
        Handles errors during navigation/page build. Delegates ErrorPage rendering to G03.
        """
        error_message = str(error)
        log_exception(error, logger=logger, context="Critical Navigation Error (Page Build)")
        
        try:
            # 1. Instantiate Controller for ErrorPage
            error_controller = self.create_full_service_controller() 
            
            # 2. Delegate rendering to G03 Renderer (G03f)
            self.renderer.render_error_page(self.error_page_class, error_controller, error_message)
            
            # 3. Publish Event
            self.publish("error_occurred", {"message": error_message, "type": "navigation"})
            
        except Exception as fallback_error:
            log_exception(fallback_error, logger=logger, context="FATAL: ErrorPage delegation failed")

    def global_error_handler(self, exc_type, exc_value, exc_traceback) -> None:
        """Global hook to catch uncaught exceptions (replaces sys.excepthook)."""
        log_exception(exc_value, logger=logger, context="Uncaught Global Exception")
        if self.window:
            self.handle_navigation_error(exc_value)
        else:
            sys.__excepthook__(exc_type, exc_value, exc_traceback)

    # =================================================================
    # --- UI-SAFE HELPERS ---
    # =================================================================

    def ui_safe_callback(self, callback: Callable, *args, **kwargs) -> None:
        """
        Executes a callable on the Tk main thread using root.after().
        """
        if self.root:
            self.root.after(0, lambda: self.execute_safe_callback(callback, *args, **kwargs))
        else:
            self.execute_safe_callback(callback, *args, **kwargs)

    def execute_safe_callback(self, callback: Callable, *args, **kwargs) -> None:
        """Executes a callback with error boundary."""
        try:
            callback(*args, **kwargs)
        except Exception as e:
            log_exception(e, logger=logger, context=f"UI-Safe Callback Error in {callback.__name__}")